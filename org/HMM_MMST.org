# -*- coding: utf-8 -*-
# -*- mode: org -*-
#+startup: beamer
#+STARTUP: overview
#+STARTUP: indent
#+TAGS: noexport(n)
#+LANGUAGE: en

#+Title:  Hidden Markov Model implementation for Mixture of Multiple Scale T-distributions
#+AUTHOR:      Steven QUINITO MASNADA

#+EPRESENT_FRAME_LEVEL: 2

#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [11pt,xcolor=dvipsnames,presentation]
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t

#+LATEX_HEADER: \usedescriptionitemofwidthas{bl}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[american]{babel}
#+LATEX_HEADER: \usepackage{amsmath,amssymb,amsthm,amsfonts}
#+LATEX_HEADER: \usepackage{bbm}
#+LATEX_HEADER: \usepackage{boxedminipage,xspace,multicol}
#+LATEX_HEADER: %%%%%%%%% Begin of Beamer Layout %%%%%%%%%%%%%
#+LATEX_HEADER: \ProcessOptionsBeamer
#+latex_header: \mode<beamer>{\usetheme{Madrid}}
#+LATEX_HEADER: \usecolortheme{whale}
#+LATEX_HEADER: \usecolortheme[named=BrickRed]{structure}
# #+LATEX_HEADER: \useinnertheme{rounded}
#+LATEX_HEADER: \useoutertheme{infolines}
#+LATEX_HEADER: \setbeamertemplate{footline}[frame number]
#+LATEX_HEADER: \setbeamertemplate{headline}[default]
#+LATEX_HEADER: \setbeamertemplate{navigation symbols}{}
#+LATEX_HEADER: \defbeamertemplate*{headline}{info theme}{}
#+LATEX_HEADER: \defbeamertemplate*{footline}{info theme}{\leavevmode%
#+LATEX_HEADER:   \hbox{%
#+LATEX_HEADER:     \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
#+LATEX_HEADER:       \usebeamerfont{author in head/foot}\insertshortauthor
#+LATEX_HEADER:     \end{beamercolorbox}%
#+LATEX_HEADER:   \begin{beamercolorbox}[wd=.41\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
#+LATEX_HEADER:     \usebeamerfont{title in head/foot}\insertsectionhead
#+LATEX_HEADER:   \end{beamercolorbox}%
#+LATEX_HEADER:   \begin{beamercolorbox}[wd=.09\paperwidth,ht=2.25ex,dp=1ex,right]{section in head/foot}%
#+LATEX_HEADER:     \usebeamerfont{section in head/foot}\insertframenumber{}~/~\inserttotalframenumber\hspace*{2ex} 
#+LATEX_HEADER:   \end{beamercolorbox}
#+LATEX_HEADER:   }\vskip0pt}
#+LATEX_HEADER: \setbeamertemplate{footline}[info theme]
#+LATEX_HEADER: %%%%%%%%% End of Beamer Layout %%%%%%%%%%%%%
#+LATEX_HEADER: \usepackage{verbments}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage{url} \urlstyle{sf}
#+LATEX_HEADER: \usepackage{appendixnumberbeamer}
#+LATEX_HEADER: \usepackage{multicol}

#+LATEX_HEADER: \let\alert=\structure % to make sure the org * * works of tools
#+BEAMER_FRAME_LEVEL: 2

#+LATEX_HEADER: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Talk Outline}\tableofcontents[currentsection]\end{frame}}

#+LATEX_HEADER: %\usepackage{biblatex}
# #+LATEX_HEADER: \bibliography{../../biblio.bib}
# #+LATEX_HEADER: \usepackage{cite}

#+LATEX_HEADER: \usepackage{xparse}

# Custom Commands
#+LATEX_HEADER: \DeclareMathOperator*{\argmax}{arg\,max}
#+LATEX_HEADER: \DeclareMathOperator*{\argmin}{arg\,min}

#+LATEX_HEADER: \newcommand{\step}[1][]{^{(#1)}}
#+LATEX_HEADER: \newcommand{\eigenv}[2]{D_{#1}\ifthenelse{\equal{#2}{}}{^{(#2)}}{}}
#+LATEX_HEADER: \DeclareDocumentCommand{\talpha}{ o o }{\tilde{\alpha} \IfValueT{#1}{_{#1}} \IfValueT{#2}{^{(#2)}}}
#+LATEX_HEADER: \DeclareDocumentCommand{\tdelta}{ o o }{\tilde{\delta} \IfValueT{#1}{_{#1}} \IfValueT{#2}{^{(#2)}}}
#+LATEX_HEADER: \DeclareDocumentCommand{\tDelta}{ o o }{\tilde{\Delta} \IfValueT{#1}{_{#1}} \IfValueT{#2}{^{(#2)}}}
#+LATEX_HEADER: \DeclareDocumentCommand{\tgamma}{ o o }{\tilde{\gamma} \IfValueT{#1}{_{#1}} \IfValueT{#2}{^{(#2)}}}
#+LATEX_HEADER: \DeclareDocumentCommand{\A}{ o o }{ A \IfValueT{#1}{_{#1}} \IfValueT{#2}{^{(#2)}}}
#+LATEX_HEADER: \DeclareDocumentCommand{\D}{ o o }{ D \IfValueT{#1}{_{#1}} \IfValueT{#2}{^{(#2)}}}

#+BEGIN_LaTeX
\newcommand{\backupbegin}{
   \newcounter{finalframe}
   \setcounter{finalframe}{\value{framenumber}}
}
\newcommand{\backupend}{
   \setcounter{framenumber}{\value{finalframe}}
}
#+END_LaTeX

#+BEGIN_LaTeX
\setbeamertemplate{caption}{\raggedright\insertcaption\par}
#+END_LaTeX

* Objective of this document
*** Objective of this document
- *Gather information* to implement HMRF based clustering
- Documentation of implementation \to *translation* from the formula to the code
  (pseudo code)
- Explanation of *optimization strategies* (memory access pattern, GPUs,
  etc...)\to maybe a tutorial
* Glossary
*** DONE Symbol definitions
# Add the dimension of Y
#+LaTeX: \scriptsize
| Definition                                                                                              |
|---------------------------------------------------------------------------------------------------------|
| N: Number of observations                                                                               |
| M: Number of gaussian components in a MST                                                               |
| K: Number of clusters                                                                                   |
|---------------------------------------------------------------------------------------------------------|
| $Y = {Y_{1},...,Y_{N}}, Y_{n} \in [1,N]$: observed variables                                                       |
| $Z = {Z_{1},...,Z_{N}}, Z_{n} \in [1,N]$: HMRF for the clusters (Gibbs distribution)                               |
| $W = {W_{1},...,W_{N}}, W_{n} \in (\mathbb{R}_{+}^{*})^{M}$: latent variable to quantify the observation information        |
|---------------------------------------------------------------------------------------------------------|
| \mu: mean                                                                                                 |
| D: eigenvectors                                                                                         |
| A: eigenvalues (diagonal matrix)                                                                        |
| \Sigma: covariance matrix = $DAD^{T}$                                                                           |
| \gamma: degree of freedom shape of the Gamma Law MST                                                         |
| \delta: degree of freedom intensity of the Gamma Law MST                                                     |
| $\Theta = (\mu, \Sigma, \gamma, \delta)$: clusters parameters                                                                 |
| \alpha: external field parameters of Z                                                                       |
| \beta: interaction parameters of Z                                                                          |
| $\psi = (\alpha,\beta)$: parameters of Z                                                                            |
| $\talpha$: parameters of the conjugate distribution                                                     |
| $\tdelta$: parameters of the conjugate distribution                                                     |
| $\tgamma$: parameters of the conjugate distribution                                                     |
|---------------------------------------------------------------------------------------------------------|
| S: Sites                                                                                                |
| \Omega(n): Neighbors of n with n \in S                                                                         |
#+LaTeX: \normalsize  
* TODO Hidden Markov Models with MMST
** DONE General
*** Observation probability distribution as MMST
**** Y - Observation as a MMST
- Mixture of MST:
$$MMST(y;\pi,\theta) = \sum_{k=1}^{K} \pi_{k} MST(y;\theta_{k})$$

- A infinite mixture of Gaussians:
$$MST(y;\mu,\Sigma,\delta,\gamma) = \int_{0}^{\infty} \mathcal{N}_{M}(y;\mu,\Sigma/w)
\mathcal{G}(w,\delta,\gamma)dw$$
**** Z - Labels as an HMRF
$$Z \sim P_{G}(\alpha,\beta)$$
**** W - Weights as a latent variable
$$W | Z \sim \mathcal{G}(\delta,\gamma)$$
*** HMRF                                                         :noexport:
# Not sure it is really necessary here, we don't care because formulas
# are already given.
**** Distribution of Z - Gibbs distribution
#+BEGIN_LaTeX
\begin{equation}
p(z;\psi) = K(\psi)^{-1} exp [H(z;\psi)]
\end{equation}
#+END_LaTeX
- Energy function
  \begin{equation}
  H(z; \psi) = \sum_{n=1}^{N} \bigg[ \alpha_{z_n} + \frac{\beta}{2} \sum_{l\in \Omega (n) } \mathbbm{1} (z_n = z_l) \bigg]
  \end{equation}

- With partition function:
  \begin{equation}
  K(\psi) = \sum_{z} \exp [H(z; \psi)]
  \end{equation}

$\alpha_{z_{n}}$ : weight of the class to which $z_{n}$ belongs\\
$\mathbbm{1}(z_n = z_l)$ : Kronecker index \to return 1 if $n$ and $l$
have the same label.

*** EM for HMM
**** E-step
- Expected complete likelihood \to approximate the posterior $p(w,z|y)$ with $q_{w,z}(w,z)$
**** M-step
1. update the mean
2. update the eigenvectors
3. update the eigenvalues
4. update the degree of freedom
5. update energy parameters
** DONE E Step
*** DONE E-step
- Complete likelihood:
  $$p(y,w,z|\theta) = p(w,z|\psi,\delta,\gamma) p(y|w,z,\theta)$$

- Posterior approximation:
  - W, Z
  - W | Z
  - Z

However Z cannot be computed \to approximated using variational methods
(mean field approximation).

Thus the posterior is computed at each site.
*** E step                                                       :noexport:
# Do details to explain the e-step, maybe more general explanation
- compute the expected complete log-likelihood:
  - Posterior probabilities:
    - In the case of HMM, posterior probabilities cannot be computed
      and must be approximated. Thus p(z,w|y) is approximated with the
      distribution q(z,w). Here q is factorized as independent
      distributions and is computed at each site.
      # Where q is a multinomial law 
      #+BEGIN_LaTeX
      \begin{equation}
      q(w,z) = \prod_{i}q_i(w_i,z_i)
      \end{equation}
      #+END_LaTeX
      with i \in S, w \in W and z \in Z.

      #+BEGIN_LaTeX
      \begin{equation}
      q_i^{t+1}(w_i,z_i) \propto exp \bigg[\mathbbm{E}_q_{i}^{t} \ln p(w_i,z_i|y, W_i^t, Z_i^t; \phi^t)\bigg]
      \end{equation}
      #+END_LaTeX
*** E step - Expected posterior                                  :noexport:
# Not really needed because we are find the posterior with the
# equation further below
- Expected posterior:
  \begin{equation}
  \begin{split}
  \mathbb{E}_{q_{w_{z_{n},w_{n}}}} [\ln p(w_n,z_n|y, w_n^{(r)}, z_n^{(r)};
  \phi^{(r)})] \\
  \approx \sum_{k=1}^{K} \mathbb{I}_{e_{k}}(z_{n}) \sum_{m=1}^{M} [(\tilde{\gamma}_{km} - 1)
  \ln(w_{nm}) - \tilde{\delta}_{knm} w_{nm} + \tilde{\gamma}_{km} \ln(\tilde{\delta}_{knm}) - ln \Gamma(\tilde{\gamma}_{km})] \\
  + \sum_{k=1}^{K} \mathbb(I)_{e_{k}} [ \tilde{\alpha}_{z_{nk}} + \frac{\beta^{(r)}}{2} \sum_{l \in \Omega(n)} q_{z_{l}}^{(r)}(e_{k})]
  \end{split}
  \end{equation}
*** DONE E step - Initialization
$q_{z_{n}}$ can be initialized at random or with an algorithm such as k-means
**** TODO Questions [0/1]
- [ ] How are initialized \alpha, \beta, \gamma, \delta ?
*** DONE E step - variables
$\alpha_{z_{n}}$: external field for each site

$\delta_{km}$: degree of freedom intensity of the $m^{th}$ normal in the $k^{th}$
cluster.

$\gamma_{km}$: degree of freedom shape of the $m^{th}$ normal in the $k^{th}$
cluster.

$a_{km}$: $m^{th}$ diagonal element of $A_{k}$

$\tilde{\delta}_{knm} = \delta_{km} + \frac{1}{2} [ A_{k}^{(r)} D_{k}^{(r)}^{t} (y_{n} - \mu_{k}^{(r)}) (y_{n} - \mu_{k}^{(r)})^{t}
          D_{k}^{(r)} ]_{mm}$

$\tilde{\gamma}_{km} = \gamma_{km} + \frac{1}{2}$

\[\tilde{\alpha}_{z_{nk}} = \alpha_{zn}^{(r)} + \sum_{m=1}^{M} [ \ln(a_{km}^{(r)}) + \gamma_{km} \ln(\delta_{km}) -
             ln \Gamma(\gamma_{km}) - \tilde{\gamma}_{km} \ln(\tilde{\delta}_{knm}) + \ln \Gamma(\tilde{\gamma}_{km})]\]
*** DONE E step - Update z
**** Equation
\begin{equation}
q_{z_{n}}^{(r+1)}(e_{k}) = \frac{ exp[ \tilde{\alpha}_{z_{nk}} +
      \frac{\beta^{(r)}}{2} \sum_{l \in \Omega(n)} q_{z_{l}}^{(r)} (e_{k})]}
      {\sum_{j=1}^{K} exp[ \tilde{\alpha}_{z_{nj}} +
      \frac{\beta^{(r)}}{2} \sum_{l \in \Omega(n)} q_{z_{l}}^{(r)} (e_{j})]}
\end{equation}
**** DONE Questions [5/5]
- [X] Do we really use the updated z map in side the r iteration?
  Yes, we do. We take into account the one updated and the one not updated.
- [X] Would it be wrong to not take into account the modification at
  step r for easier parallelism?
  Convergence properties no guarantied.
- [X] Do we use as well the updated version of \alpha?
  No it is just updated at each iteration r.
- [X] Is M the normal dimension of a MST?
  Yes
- [X] What are $\tilde{\alpha}_{z_{nk}}$ $\delta$ and $\gamma$?
  +Update of the \alpha $\tdelta$ and $\tgamma$ for the posterior.+
  They are just a re-writing to expose the gamma distribution.
*** DONE E step - Update w|z
**** Equation
\begin{equation}
q_{w_{n}|z_{n}}^{(r+1)}(w_{n} | z_{n} = e_{k}) = \prod_{m=1}^{M} \tilde{\delta}_{knm}^{\tilde{\gamma}_{km}} \Gamma(\tilde{\gamma}_{km})^{-1} w_{nm}^{(\tilde{\gamma}_{km}-1)} exp(- \tilde{\delta}_{knm} w_{nm})
\end{equation}

**** Remarks
- Here we can spot that this is just a product of gamma distributions
**** DONE Questions [1/1]
- [X] What is $w_{n}$ ? Which values can it take?
  It is the proximity of an observation to the center of the
  class. The closer from the center, the more important. In other
  words it is the quantity of information provided by an observation.
  # Proximité avec le centre de la classe. Plus une observation est
  # proche du centre plus elle à de l'importance. Quantité d'information
  # apporté par une observation.
*** DONE E step - Update w,z
**** Equation
\begin{equation}
q_{w_{n},z_{n}}^{(r+1)}(w_{n},z_{n}) =  \prod_{k=1}^{K} q_{w_{n}|z_{n}}^{(r+1)}(w_{n} | z_{n} = e_{k}) . q_{z_{n}}^{(r+1)}(z_{n}_{})
\end{equation}

**** DONE Questions [1/1]
- [X] $q_{_z_{n}}^{(r+1)} (z_{n} = e_{k})$ ?
  In fact the second term in not in the product as I suspected.
** TODO M Step
*** DONE M step
- Maximize the expected complete log-likelihood:
  - Step 1:
    - Update the mean
    - Update the eigenvectors
    - Update the eigenvalues
  - Step 2:
    - Update degree of freedom
  - Step 3:
    - Update Gibbs distribution parameters
*** TODO M Step - Variables
$\tilde{\Delta}_{nk}^{(r+1)} = \mathbbm{E}_{q_{w_{n}|z_{n} = e_{k}}}^{(r+1)} (\Delta_{n})$
**** TODO Questions [0/3]
- [ ] How do we compute it? Is it something like:
$\mathbbm{E}_{q_{w_{n}|z_{n} = e_{k}}}^{(r+1)} (\Delta_{n}) = \int_{0}^{\infty}
\Delta_{n} q_{w_{n},z_{n}}(w_{n},z_{n})$

- [ ] How what do we integrate? \Delta?

- [ ] Is it supposed to be $\Delta_{n}^{(r)$} instead of just $\Delta_{n}$?
*** DONE M Step - update mean \mu
**** Equation
\begin{equation}
\mu_{km}^{(r+1)} = \frac{\sum_{n=1}^{N} q_{z_{n}}^{(r+1)}(e_{k}) \Big[
D_{k}^{(r)} \tDelta[nk][r+1] D_{k}^{(r)}^{t} y_{n }\Big]_{m}}
              {\sum_{n=1}^{N} q_{z_{n}}^{(r+1)}(e_{k}) \tDelta[nkm][r+1]}
\end{equation}
*** TODO M Step - update eigenvectors D
**** Equation
\begin{equation}
D_{k}^{(r+1)} =  \argmin_{D_{k}} \sum_{n=1}^{N} tr \Big[ \D[k] \tDelta[nk][r+1] \A[k][r] \D[k]^{t} (y_{n} - \mu_{k}^{(r+1)}) (y_{n} - \mu_{k}^{(r+1)})^{t} \Big]
\end{equation}
**** Remarks
- The space of the orthogonal matrix $D_{k}$ is not convex \to use Flury and
  Gautschi algorithm.
 
- $tr$ \to trace function
**** DONE Questions [1/1]                                       :noexport:
- [X] What is tr?
  Trace \to sum of the diagonal values.
*** DONE M Step - update eigenvalues A
**** Equation
\begin{equation}
\A[km][r+1] = \frac{ \sum_{n=1}^{N} q_{z_{n}}^{(r+1)} (e_{k}) }{ \sum_{n=1}^{N} q_{z_{n}}^{(r+1)} (e_{k}) \tDelta[nkm][r+1] \big[ \D[k][r+1]^{t} (y_{n }- \mu_{k}^{(r+1)}) \big]_{m}^{2} }
\end{equation}
*** DONE M Step - update degree of freedom \gamma, \delta
Solving a system of nonlinear equation:

\begin{cases}
\Psi(\gamma_{km}) = \Psi(\gamma_{km}^{(r+1)}) + \frac{\sum_{n=1}^{N} q_{z_{n}}(e_{k})\ln(\frac{\tdelta[nkm]}
                                                {\tdelta[nkm][r+1]})}
                         {\sum_{l=1}^{N} q_{z_{l}}(e_{k})}\\
\tdelta[nkm] = \tdelta[nkm][r+1] \frac{\gamma_{km}}{\gamma_{km}^{(r+1)}}\\
\delta_{km} = 1
\end{cases}
**** Remarks
- They are tilde somewhere but I am not sure where...
- The second line is a constant, but I don't see why...
- Still not sure how to solve the systems...

*** TODO M Step - update fields parameters \alpha, \beta
- This step is skipped for now, the optimization of \alpha and \beta is tricky to
  do, and $SpaceM^{3}$ as already something to do this.

- For now $\alpha_{z_{n}}$ can be set to $w_{n}$.
**** TODO Questions [0/1]
- [ ] But what about \beta?

* TODO Pseudo-code
# Using ruby syntax just for syntax highlighting
** Variable declarations
#+BEGIN_EXAMPLE
int step
boolean converged
int size_x, size_y, size_z
real obs[size_x][size_y][size_z]
real q_z[size_x][size_y][size_z]
#+END_EXAMPLE
** Body
#+begin_src ruby
  while not converged
    
    step++ 
  end
#+end_src
* TODO Implementation details
** TODO Manipulated data structures
** TODO Used Libraries
*** TODO BOAST
*** TODO StarPU
** TODO Default Implementation
** TODO Verification / correctness
*** correctness
- What is the delta?
** TODO Optimization
*** TODO Memory access pattern
*** TODO Parallelism - Task paradigm
- Computation = task \to vertexes
- Dependencies between computation = edges
- A task cannot start if data not arrived from dependencies
- As Z is an HMRF it as non-trivial dependencies \to can be modeled as a
  task graph 
- We could use StarPU \to  schedule dynamically the tasks according to the
  dependencies (CPU, GPU, clusters)
*** TODO Code generation approach and tuning
**** Maybe BOAST?
- Meta-programming framework: ruby \to C, Fortran, CUDA, OpenCL
- Generate multiple variant of same code e.g. loop unrolled,
  vectorized, size of tiling, etc...
- *Portable optimization*
*** TODO Performance analysis
** Sandbox                                                         :noexport:
   #+begin_src R :results output :session :exports both
     library("png")
     library("plyr")
     y <- readPNG("images_2.png")
     nrow_img <- nrow(y)
     ncol_img <- ncol(y)
   #+end_src

   #+RESULTS:

   Generate a noisy image:
   #+begin_src R :results output :session :exports both
     # noise_mat <- matrix(rbinom(ncol_img*nrow_img,1,0.2), nrow = nrow_img, ncol = ncol_img)
     # noisy_img <- matrix(bitwXor(y,noise_mat), ncol=ncol_img)

     noise_mat <- matrix(rnorm(ncol_img*nrow_img, mean = 0.5, sd=0.2), nrow = nrow_img, ncol = ncol_img)
     noisy_img <- y + noise_mat
     noisy_img <- (noisy_img - min(noisy_img)) / (max(noisy_img) - min(noisy_img)) # normalization

     image(noisy_img)
   #+end_src

   #+RESULTS:

   #+begin_src R :results output graphics :file (org-babel-temp-file "figure" ".png") :exports both :width 600 :height 400 :session
   hist(noisy_img)
   #+end_src

   #+RESULTS:
   [[file:/tmp/babel-6164uvh/figure61647eQ.png]]


   #+begin_src R :results output :session :exports both

   #+end_src


* Emacs Setup 							   :noexport:
  This document has local variables in its postembule, which should
  allow Org-mode to work seamlessly without any setup. If you're
  uncomfortable using such variables, you can safely ignore them at
  startup. Exporting may require that you copy them in your .emacs.

# Local Variables:
# eval:    (require 'org-install)
# eval:    (org-babel-do-load-languages 'org-babel-load-languages '( (sh . t) (R . t) (perl . t) (ditaa . t) ))
# eval:    (setq org-confirm-babel-evaluate nil)
# eval:    (unless (boundp 'org-latex-classes) (setq org-latex-classes nil))
# eval:    (add-to-list 'org-latex-classes '("memoir" "\\documentclass[smallextended]{memoir} \n \[NO-DEFAULT-PACKAGES]\n \[EXTRA]\n  \\usepackage{graphicx}\n  \\usepackage{hyperref}" ("\\chapter{%s}" . "\\chapter*{%s}") ("\\section{%s}" . "\\section*{%s}") ("\\subsection{%s}" . "\\subsection*{%s}")                       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")                       ("\\paragraph{%s}" . "\\paragraph*{%s}")                       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
# eval:    (add-to-list 'org-latex-classes '("acm-proc-article-sp" "\\documentclass{acm_proc_article-sp}\n \[NO-DEFAULT-PACKAGES]\n \[EXTRA]\n"  ("\\section{%s}" . "\\section*{%s}") ("\\subsection{%s}" . "\\subsection*{%s}")                       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")                       ("\\paragraph{%s}" . "\\paragraph*{%s}")                       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
# eval:    (setq org-alphabetical-lists t)
# eval:    (setq org-src-fontify-natively t)
# eval:   (setq org-export-babel-evaluate nil)
# eval:   (setq ispell-local-dictionary "english")
# eval:   (eval (flyspell-mode t))
# eval:    (setq org-latex-listings 'minted)
# eval:    (setq org-latex-minted-options '(("bgcolor" "white") ("style" "tango") ("numbers" "left") ("numbersep" "5pt")))
# End:
